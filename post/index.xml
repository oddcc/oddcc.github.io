<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on CodeTalk</title>
    <link>http://blog.chenhq.ren/post/</link>
    <description>Recent content in Posts on CodeTalk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Feb 2021 11:02:13 +0800</lastBuildDate><atom:link href="http://blog.chenhq.ren/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>什么是字典树（Trie）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie%EF%BC%89/</link>
      <pubDate>Wed, 24 Feb 2021 11:02:13 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie%EF%BC%89/</guid>
      <description>解决什么问题 我们有如下需求，给出4*4的字母表，我们可以通过把相邻（横向、竖向、斜向都算相邻）的字母连接起来组成一个单词，要找到所有单词。像下图画的WAIT就算是一个单词。假设我们已经有所有单词的词库。 容易想到的方法是我们可以从左上角[0,0]开始，用DFS的方法进行搜索；之后再</description>
    </item>
    
    <item>
      <title>什么是单调队列（Monotonic Queue）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88Monotonic%20Queue%EF%BC%89/</link>
      <pubDate>Tue, 23 Feb 2021 11:02:48 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88Monotonic%20Queue%EF%BC%89/</guid>
      <description>什么是单调队列（单调栈） 简单的说，就是栈内的元素，满足某种单调性，比如栈内的元素是单调递增的，那么pop()的时候，得到的就一定是当前栈内最大的元素。 单调栈可以用O(1)的复杂度获得当前栈内元素的最大（最小）值。在有新元素入栈时，破坏了单调性的元素会被出栈，且不会再次入栈。 比如我</description>
    </item>
    
    <item>
      <title>什么是前缀和数组（Prefix Sum Array）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%88Prefix%20Sum%20Array%EF%BC%89/</link>
      <pubDate>Mon, 22 Feb 2021 17:48:15 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%88Prefix%20Sum%20Array%EF%BC%89/</guid>
      <description>遇到的问题 如果有数组arr 0 1 2 3 4 5 6 arr -&amp;gt; 2 5 4 9 7 1 0 我们需要频繁的求任意子数组的元素的和，应该如何求解？最容易想到的就是循环求和，但这是个O(N)的操作。有没有什么办法可以让我们可以用O(1)的时间复杂度来得到子数组的和？ 什么是前缀和数组 如果对于数组arr，我们有如下的数组</description>
    </item>
    
    <item>
      <title>什么是差分数组（difference Array）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%88difference%20Array%EF%BC%89/</link>
      <pubDate>Mon, 22 Feb 2021 17:09:54 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%88difference%20Array%EF%BC%89/</guid>
      <description>遇到的问题 有一个数组arr，我们需要频繁对arr中的子数组进行更新，比如为子数组的元素+1，容易想到的办法是每次都用一个循环进行更新，但这其实是个时间复杂度O(N)的操作，效率是不高的。有没有什么办法可以高效的进行更新（比如O(1)的时间复杂度）？ 什么是差分数组？ 如果我们有个数组</description>
    </item>
    
    <item>
      <title>WH-1000XM3通过NFC连接到iPhone</title>
      <link>http://blog.chenhq.ren/2021/01/WH-1000XM3%E9%80%9A%E8%BF%87NFC%E8%BF%9E%E6%8E%A5%E5%88%B0iPhone/</link>
      <pubDate>Mon, 18 Jan 2021 15:32:30 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/01/WH-1000XM3%E9%80%9A%E8%BF%87NFC%E8%BF%9E%E6%8E%A5%E5%88%B0iPhone/</guid>
      <description>WH-1000X M3跟安卓手机配合是很好的，比如我的小米8，只要非锁屏状态下靠近NFC区域，就可以自动连接耳机。自从变成双机党（还有一台iPhone SE2）之后，多设备切换就成了问题，在发现本文的方法之前，最快的方式是 安卓打开蓝牙菜单，点WH-1000X M3断开当前连接 ios打开蓝牙菜单，点W</description>
    </item>
    
    <item>
      <title>gilab-runner源码阅读记录（一）</title>
      <link>http://blog.chenhq.ren/2020/12/gilab-runner%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</link>
      <pubDate>Wed, 23 Dec 2020 08:21:09 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/12/gilab-runner%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;接之前的文章，单纯把整个流程调通了上到生产环境发现还是不满足所有需求。比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持指定多个subnet和instance-type，导致的结果就是如果指定了subnet和instance-type，就只能在一个zone中请求spot实例，经常会出现没有相关资源的情况（capacity-not-available）。这时候所有CI请求就被block住了，因为没有新的机器可以运行，只能等已有任务跑完，复用已有的机器&lt;/li&gt;
&lt;li&gt;既然是为了节省成本，当然选比较低配的机型，只要能跑通CI即可。但是有一些项目需要的资源是比较高的，我们选的机型是2C2G的机型，某些项目跑CI就会出现OOM（out of memory）的情况。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>威联通 453Bmini 静态卷扩容记录</title>
      <link>http://blog.chenhq.ren/2020/12/%E5%A8%81%E8%81%94%E9%80%9A-453bmini-%E9%9D%99%E6%80%81%E5%8D%B7%E6%89%A9%E5%AE%B9%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 10 Dec 2020 03:25:10 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/12/%E5%A8%81%E8%81%94%E9%80%9A-453bmini-%E9%9D%99%E6%80%81%E5%8D%B7%E6%89%A9%E5%AE%B9%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;这个NAS当初买回来的时候还比较青涩，配了一个4T的盘并且没有做好规划。当时只是认定了要使用静态卷来存储，不使用各种Raid，没有仔细考虑过如果4T的盘满了，要如何进行扩容。&lt;/p&gt;
&lt;p&gt;事实上一旦开始囤电影电视剧，这块4T的盘很快就满了。威联通是有系统盘一说的，虽然可以选则APP装在哪个盘上，但像我这种情况，肯定都是装在4T的盘上的，所以盘中除了资料之外，还有整个NAS的配置，各种Docker、虚拟机等等，甚至家里的主路由都跑在这台NAS上。&lt;/p&gt;
&lt;p&gt;为了避免把这么多东西都重新配置一遍，我想做到无痛扩容，本来以为会有类似TimeMachine迁移的方法，直接把新硬盘插上，直接迁移就可以，结果发现并没有…官方的扩容方法只能是通过组Raid来进行扩容，并且官方没有把Raid转为静态卷的方法。不得已只能冒着损失资料的风险自己折腾了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>接触了一些新语言后，回头看Java 8之后的更新</title>
      <link>http://blog.chenhq.ren/2020/11/%E6%8E%A5%E8%A7%A6%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B0%E8%AF%AD%E8%A8%80%E5%90%8E%EF%BC%8C%E5%9B%9E%E5%A4%B4%E7%9C%8Bjava-8%E4%B9%8B%E5%90%8E%E7%9A%84%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Mon, 30 Nov 2020 08:18:02 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/11/%E6%8E%A5%E8%A7%A6%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B0%E8%AF%AD%E8%A8%80%E5%90%8E%EF%BC%8C%E5%9B%9E%E5%A4%B4%E7%9C%8Bjava-8%E4%B9%8B%E5%90%8E%E7%9A%84%E6%9B%B4%E6%96%B0/</guid>
      <description>&lt;p&gt;Java一直被认为是一门啰嗦的语言，有个段子是调侃一个小项目，用Java写就会变成大项目。但Java同时也使用广泛，工程性强，写Java的人也是最多。对Java的这些特点，在没写过太多其他语言之前，我的认识很肤浅，有点人云亦云的感觉。在最近因为工作原因写了大量go、Javascript、TypeScript代码之后，再回头来看Java，居然没有像常见到的那些写了go就不想碰Java的观点一样感到轻松，而是十分怀念…&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>记一次被迫参加开源的经历</title>
      <link>http://blog.chenhq.ren/2020/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A2%AB%E8%BF%AB%E5%8F%82%E5%8A%A0%E5%BC%80%E6%BA%90%E7%9A%84%E7%BB%8F%E5%8E%86/</link>
      <pubDate>Wed, 25 Nov 2020 04:00:50 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A2%AB%E8%BF%AB%E5%8F%82%E5%8A%A0%E5%BC%80%E6%BA%90%E7%9A%84%E7%BB%8F%E5%8E%86/</guid>
      <description>&lt;p&gt;公司的CI目前是在固定的几台机器上跑，有几个问题，一个是没有伸缩性，高峰期时甚至有CI等到过期了都没排到机器；另一个是空闲时又要浪费不小的运营成本，毕竟机器开在那里就扣费的。&lt;/p&gt;
&lt;p&gt;出于节省公司运营成本的考虑，决定把跑CI的机器由固定配置改成可伸缩的，由于代码管理是在自建的gitlab上面，云服务使用的是AWS，所以调研了几个方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用AWS Fargate实现（&lt;a href=&#34;https://docs.gitlab.com/runner/configuration/runner_autoscale_aws/&#34;&gt;官方文档&lt;/a&gt;），但Fargate有自己的限制，即不支持Docker-in-Docker，所以只能跑一些简单的CI。我们的发版操作也是用CI跑的，所以官方的方式不行。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>记一次 Xbox One 手柄的复活</title>
      <link>http://blog.chenhq.ren/2020/08/%E8%AE%B0%E4%B8%80%E6%AC%A1-xbox-one-%E6%89%8B%E6%9F%84%E7%9A%84%E5%A4%8D%E6%B4%BB/</link>
      <pubDate>Mon, 03 Aug 2020 08:44:20 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/08/%E8%AE%B0%E4%B8%80%E6%AC%A1-xbox-one-%E6%89%8B%E6%9F%84%E7%9A%84%E5%A4%8D%E6%B4%BB/</guid>
      <description>&lt;p&gt;新装了一台电脑，终于可以在这台4k屏幕上打游戏了……激动的拿出来尘封许久的Xbox One的手柄，发现按了开关之后一点反应都没有，打开电池仓一看，电池漏液了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何在新电脑上玩那些低分辨率的老游戏？</title>
      <link>http://blog.chenhq.ren/2020/07/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%8E%A9%E9%82%A3%E4%BA%9B%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E8%80%81%E6%B8%B8%E6%88%8F%EF%BC%9F/</link>
      <pubDate>Wed, 22 Jul 2020 09:07:36 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/07/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%8E%A9%E9%82%A3%E4%BA%9B%E4%BD%8E%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E8%80%81%E6%B8%B8%E6%88%8F%EF%BC%9F/</guid>
      <description>&lt;h2 id=&#34;事情的起因是这样的&#34;&gt;事情的起因是这样的……&lt;/h2&gt;
&lt;p&gt;我日常使用的主力是一台 MacBook Pro (15-inch, 2017) 在工作之余，也用它开虚拟机打打老游戏。一方面是确实怀旧，总感觉现在新的游戏虽然画面很绚，但是游戏就是不好玩；另一方面是 MacBook 也就只能玩玩老游戏了（摔）。&lt;/p&gt;
&lt;p&gt;用的虚拟机是 Parallels Desktop，有时会在27寸的外接屏幕上玩，所以就遇到一个问题，就是分辨率的问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 对象在内存中是如何表示的</title>
      <link>http://blog.chenhq.ren/2020/07/java-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E7%9A%84/</link>
      <pubDate>Mon, 20 Jul 2020 08:07:42 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/07/java-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E7%9A%84/</guid>
      <description>&lt;h2 id=&#34;背景知识&#34;&gt;背景知识&lt;/h2&gt;
&lt;p&gt;JVM 规范中没有限制对象在内存中是怎么表示的，具体的设计方式取决于各 JVM 实现，我们就以最常见的 HotSpot 为例来说明。&lt;/p&gt;
&lt;p&gt;HotSpot JVM 是用一种叫做 Ordinary Object Pointer（OOP）的数据结构来表示指向对象的指针。在 OOP 中，最重要的是 mark word 和klass word：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mark word 中包含了唯一标识一个对象的hashcode，关于锁的信息，GC的信息。mark word占用4字节（32位架构中，64位架构中是8字节），其中关于锁的信息，在对象使用偏向锁和普通锁的时候，存储方式是完全不同的。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Shell 快速上手</title>
      <link>http://blog.chenhq.ren/2020/04/shell-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Wed, 01 Apr 2020 14:01:02 +0000</pubDate>
      
      <guid>http://blog.chenhq.ren/2020/04/shell-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid>
      <description>&lt;h2 id=&#34;什么是shell&#34;&gt;什么是Shell？&lt;/h2&gt;
&lt;p&gt;现代的电脑可以以很多种方式跟人进行交互，如图形界面，语音，甚至AR/VR都可以实现交互。使用这些方式已经可以满足绝大部分的用户需求了，但是使用这些交互方式，我们的行为依然是受限的。我们使用的是已经被定义好的功能的集合，以图形界面来说，每一个按钮的行为都是已经被编写图形界面的程序员写好的，我们没法通过图形界面做到没有被定义过的行为。&lt;/p&gt;
&lt;p&gt;这就意味着始终有一些功能，电脑是可以做到的，但是我们却无法通过图形界面等方式告诉电脑做这些事情。但利用 shell 则不同，通过 shell，我们可以利用电脑提供的所有功能。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
