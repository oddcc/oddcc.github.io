<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on CodeTalk</title>
    <link>http://blog.chenhq.ren/categories/Algorithm/</link>
    <description>Recent content in Algorithm on CodeTalk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Mar 2021 15:40:14 +0800</lastBuildDate><atom:link href="http://blog.chenhq.ren/categories/Algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于并查集（Disjoint Set Union或Union Find）</title>
      <link>http://blog.chenhq.ren/2021/03/%E5%85%B3%E4%BA%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Disjoint%20Set%20Union%E6%88%96Union%20Find%EF%BC%89/</link>
      <pubDate>Tue, 02 Mar 2021 15:40:14 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/03/%E5%85%B3%E4%BA%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Disjoint%20Set%20Union%E6%88%96Union%20Find%EF%BC%89/</guid>
      <description>什么是并查集 并查集说的是这样一种数据结构，对外提供三个（一个属于可选）接口 add(x): void （可选）表示添加一个元素x，这个元素x属于自己一个单独的子集 find(x): element 表示在整个数据结构中找一个元素x，返回x所属子集的根（root，这里假设了子集是个树，有根节点，实际上这里也可以是子集的编号等等，总之是可</description>
    </item>
    
    <item>
      <title>关于LRU（Latest Recently Used）算法</title>
      <link>http://blog.chenhq.ren/2021/03/%E5%85%B3%E4%BA%8ELRU%EF%BC%88Latest%20Recently%20Used%EF%BC%89%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Mar 2021 10:20:09 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/03/%E5%85%B3%E4%BA%8ELRU%EF%BC%88Latest%20Recently%20Used%EF%BC%89%E7%AE%97%E6%B3%95/</guid>
      <description>解决什么问题 想象我们有一个缓存系统，里面以key-value的形式存储了很多缓存数据，但存储空间总是有限的，如果我们不断的接受请求，那么总有存满的一天。当存储空间存满了之后，我们就要通过某种方式去释放空间，不然我们的缓存系统就无法接受新的请求了。 那么作为一个缓存系统，我们其实希望</description>
    </item>
    
    <item>
      <title>什么是字典树（Trie）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie%EF%BC%89/</link>
      <pubDate>Wed, 24 Feb 2021 11:02:13 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie%EF%BC%89/</guid>
      <description>解决什么问题 我们有如下需求，给出4*4的字母表，我们可以通过把相邻（横向、竖向、斜向都算相邻）的字母连接起来组成一个单词，要找到所有单词。像下图画的WAIT就算是一个单词。假设我们已经有所有单词的词库。 容易想到的方法是我们可以从左上角[0,0]开始，用DFS的方法进行搜索；之后再</description>
    </item>
    
    <item>
      <title>什么是单调队列（Monotonic Queue）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88Monotonic%20Queue%EF%BC%89/</link>
      <pubDate>Tue, 23 Feb 2021 11:02:48 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88Monotonic%20Queue%EF%BC%89/</guid>
      <description>什么是单调队列（单调栈） 简单的说，就是栈内的元素，满足某种单调性，比如栈内的元素是单调递增的，那么pop()的时候，得到的就一定是当前栈内最大的元素。 单调栈可以用O(1)的复杂度获得当前栈内元素的最大（最小）值。在有新元素入栈时，破坏了单调性的元素会被出栈，且不会再次入栈。 比如我</description>
    </item>
    
    <item>
      <title>什么是前缀和数组（Prefix Sum Array）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%88Prefix%20Sum%20Array%EF%BC%89/</link>
      <pubDate>Mon, 22 Feb 2021 17:48:15 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%88Prefix%20Sum%20Array%EF%BC%89/</guid>
      <description>遇到的问题 如果有数组arr 0 1 2 3 4 5 6 arr -&amp;gt; 2 5 4 9 7 1 0 我们需要频繁的求任意子数组的元素的和，应该如何求解？最容易想到的就是循环求和，但这是个O(N)的操作。有没有什么办法可以让我们可以用O(1)的时间复杂度来得到子数组的和？ 什么是前缀和数组 如果对于数组arr，我们有如下的数组</description>
    </item>
    
    <item>
      <title>什么是差分数组（difference Array）</title>
      <link>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%88difference%20Array%EF%BC%89/</link>
      <pubDate>Mon, 22 Feb 2021 17:09:54 +0800</pubDate>
      
      <guid>http://blog.chenhq.ren/2021/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%88difference%20Array%EF%BC%89/</guid>
      <description>遇到的问题 有一个数组arr，我们需要频繁对arr中的子数组进行更新，比如为子数组的元素+1，容易想到的办法是每次都用一个循环进行更新，但这其实是个时间复杂度O(N)的操作，效率是不高的。有没有什么办法可以高效的进行更新（比如O(1)的时间复杂度）？ 什么是差分数组？ 如果我们有个数组</description>
    </item>
    
  </channel>
</rss>
